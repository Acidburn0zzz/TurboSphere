import os
import sys

defaultenv = Environment(ENV = os.environ)

msvc_ccflags = "/O2 /EHsc /Zi"
msvc_cflags = ""
msvc_cxxflags = ""

gcc_ccflags = " -Werror=return-type -Wall -Wno-pointer-arith -mtune=native -flto -O2 -Wcast-align -g "
gcc_cflags = " -std=c11 "
gcc_cxxflags = " -std=c++11 "

if os.environ['TRAVIS'] == 'true':
  gcc_cflags = " -std=gnu0x "
  gcc_cxxflags = " -std=gnu++0x "

clang_ccflags = gcc_ccflags + " -DHAS_UNISTD -DHAS_STAT_SYS -DUSE_STAT -Wno-return-type-c-linkage -Wno-null-arithmetic "
clang_cflags = gcc_cflags
clang_cxxflags = gcc_cxxflags

#Checking platform.

def IsWindows():
  return sys.platform == 'win32' or sys.platform.startswith('win64')

def IsLinux():
  return sys.platform.startswith('linux')

def IsDarwin():
  return sys.platform == 'darwin'

compiler = ""

# Perform extra futzing for shared libraries on Unix platforms.

def LibraryInstall(name, library, env):
  if(IsDarwin()):
    print library[0].name
    LibraryFileName = os.path.join(os.getcwd(), library[0].name)
    return env.Command(os.path.join(name, library[0].name), LibraryFileName, "install_name_tool $SOURCE -id $TARGET && cp $SOURCE $TARGET ")
  else:
    return env.Install(name, [library])

#Todo: Make these overrideable.
if IsWindows():
  compiler = 'msvc'
elif IsLinux():
  compiler = 'gcc'
elif IsDarwin():
  compiler = 'clang'
else:
  compiler = 'cc' # who knows.

#Create a unified environment.
globalenv = defaultenv.Clone()

if os.name == 'posix':
  globalenv.Append(tools = ['default', 'textile'])

if compiler == 'msvc':
  globalenv.Replace(CCFLAGS = msvc_ccflags, CFLAGS = msvc_cflags, CXXFLAGS = msvc_cxxflags)
if compiler == 'gcc':
  globalenv.Replace(CCFLAGS = gcc_ccflags, CFLAGS = gcc_cflags, CXXFLAGS = gcc_cxxflags)
if compiler == 'clang':
  globalenv.Replace(CCFLAGS = clang_ccflags, CFLAGS = clang_cflags, CXXFLAGS = clang_cxxflags)

def CheckForHeader(env, conf, header_name, macro_name):
  if conf.CheckCHeader(header_name) or conf.CheckCXXHeader(header_name):
    env.Append(CPPDEFINES = macro_name)
    return True
  return False

# Linux requires we check if the include files are in X/Open or SysV locations.
conf = Configure(globalenv.Clone())
if IsLinux():
  if CheckForHeader(globalenv, conf, 'tbb/concurrent_queue.h', "HAS_INTEL_TBB"):
    # Use Intel Thread Building Blocks whenever available.
    globalenv.Append(CPPDEFINES= "USE_INTEL_TBB")
  CheckForHeader(globalenv, conf, 'atomic', "HAS_ATOMIC")
  CheckForHeader(globalenv, conf, 'thread', "HAS_THREAD")
  CheckForHeader(globalenv, conf, 'mutex', "HAS_MUTEX")
  CheckForHeader(globalenv, conf, 'unistd.h', "HAS_UNISTD")
  CheckForHeader(globalenv, conf, 'sys/unistd.h', "HAS_UNISTD_SYS")
  if CheckForHeader(globalenv, conf, 'stat.h', "HAS_STAT") or CheckForHeader(globalenv, conf, 'stat.h', "HAS_STAT_SYS"):
    globalenv.Append(CPPDEFINES = "USE_STAT")
  CheckForHeader(globalenv, conf, 'types', "HAS_TYPES")
  CheckForHeader(globalenv, conf, 'sys/types', "HAS_TYPES_SYS")

conf.Finish()

# OS X has singular define locations:
if IsDarwin():
    globalenv.Append(CPPDEFINES = ["HAS_UNISTD", "HAS_STAT_SYS", "USE_STAT"])
    globalenv.Append(CPPDEFINES = ["OS_X"]) # We could probably just trust __APPLE__ or __MACH__.

# Because Windows requires different functions entirely, it is implemented as a unique code path in
# the source code proper.

librarydir = os.path.join(os.getcwd(), "lib")
binarydir  = os.path.join(os.getcwd(), "bin")

localenv = globalenv.Clone()

# perform config.
libconfig = SConscript(dirs = ["lib"], exports = "globalenv localenv")

#because this was a config script, we copy back what it set.
globalenv = libconfig.Clone()
localenv  = libconfig.Clone()

# Begin the build proper.
build = SConscript(dirs = ["extra"], exports = "globalenv localenv IsLinux IsWindows IsDarwin LibraryInstall compiler librarydir binarydir ")
build = SConscript("src/Sconscript", exports = "globalenv localenv IsLinux IsWindows IsDarwin LibraryInstall compiler librarydir binarydir ")
