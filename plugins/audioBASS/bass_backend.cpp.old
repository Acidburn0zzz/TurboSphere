#include "include/bass.h"
#include "frontend.h"
#include "bass_backend.h"
#include <cmath>
#include <cassert>
//TODO: Add seperate error for OS X.
#ifdef _WIN32
static const char *TS_MSG_DXError = "DirectX is not installed.\n";
#define fabs TS_FABS
#else
static const char *TS_MSG_DXError = "ALSA is not installed.";
#endif

static DWORD *defaultSoundFont;

//TODO: Perhaps having a T5 file (and even localizations) would be a good idea?
static const char *TS_MSG_WillReopen    = "\tTurboSphere will attempt to close and reopen the device.";
static const char *TS_MSG_WillChangeFmt = "\tTurboSphere will attempt to start audio with different settings.";
static const char *TS_MSG_BadDevice     = "Invalid device. This probably means you have bad drivers, or no working audio output devices.";
static const char *TS_MSG_AlreadyOpen   = "The device has already been initialized.";
static const char *TS_MSG_BadDriver     = "There is no available device driver.";
static const char *TS_MSG_BadFormat     = "The default default format is not supported by the device.";
static const char *TS_MSG_BadFormatFS   = "The default failsafe format is not supported by the device.";
static const char *TS_MSG_OutOfMemory   = "Out of memory.";
static const char *TS_MSG_UnkownErrorPRT= "Unkown error (internal code is [decimal] %i).";

uint64_t generateUniqueId(int skip = 0){
    static uint64_t ID = 0;
    ID+=skip;
    return ID++;
}

void TS_ExplainBassErrorCode(int error, bool willTryAgain, bool FormatIsFailsafe){

    printf("[" PLUGINNAME "] Error: Could not initialize BASS. ");

    switch(error){
        case BASS_ERROR_DX:
            printf(TS_MSG_DXError);
            break;
        case BASS_ERROR_DEVICE:
            printf(TS_MSG_BadDevice);
            break;
        case BASS_ERROR_ALREADY:
            printf(TS_MSG_AlreadyOpen);
            if(willTryAgain){
                printf("\n");
                printf(TS_MSG_WillReopen);
            }
            break;
        case BASS_ERROR_DRIVER:
            printf(TS_MSG_BadDriver);
            if(willTryAgain){
                printf("\n");
                printf(TS_MSG_WillReopen);
            }
            break;
        case BASS_ERROR_FORMAT:
            if(!FormatIsFailsafe){
                printf(TS_MSG_BadFormat);
            }
            else{
                printf(TS_MSG_BadFormatFS);
            }
            if(willTryAgain){
                printf("\n");
                printf(TS_MSG_WillChangeFmt);
            }
        case BASS_ERROR_MEM:
            printf(TS_MSG_OutOfMemory);
            break;
        default:
            printf(TS_MSG_UnkownErrorPRT, error);
    }
    printf("\n");
}

int TS_InitBassMidi(){

    TS_Config *TS_Conf = GetConfig();
    TS_Directories *TS_Dirs = GetDirs();

    HPLUGIN bassmidi;
    #ifdef _WIN32
        bassmidi = BASS_PluginLoad("bassmidi.dll", 0);
    #elif defined(__linux__)
        bassmidi = BASS_PluginLoad("libbassmidi.so", 0);
    #else // OSX?
        bassmidi = BASS_PluginLoad("libbassmidi.dylib", 0);
    #endif
    bool bassMidiLoaded = true;
    int error = BASS_ErrorGetCode();
    if(error){
        printf("[" PLUGINNAME "] Warning: Could not initialize BASSmidi.");
        printf(TS_MSG_UnkownErrorPRT, error);
        printf("\n");
        bassMidiLoaded = false;
    }
    else{
        printf("[" PLUGINNAME "] Info: Initialized BASSmidi as bass plugin %i.\n", bassmidi);
    }
    defaultSoundFont = (DWORD *)malloc(sizeof(DWORD));

    *defaultSoundFont = BASS_MIDI_FontInit(string(TS_Dirs->system).append(TS_Conf->systemsoundfont).c_str(), 0);

    BASS_MIDI_FONT defaultFont;

    BASS_MIDI_StreamGetFonts(0, &defaultFont, 1);

    defaultFont.font   = *defaultSoundFont;
    defaultFont.preset = -1;
    defaultFont.bank   = 0;

    if(!BASS_MIDI_StreamSetFonts(0, &defaultFont, 1))
        bassMidiLoaded = false;

    if(!bassMidiLoaded){
        printf("[" PLUGINNAME "] Warning: Could not initialize MIDI support. Sound will still function, but MIDI files will not play.\n");
    }

    error = BASS_ErrorGetCode();
    if((!bassMidiLoaded)||(error)){
        printf("[" PLUGINNAME "] Warning: Could not load the default sound font. ");
        switch(error){
            case BASS_ERROR_HANDLE:
                 printf("Check that the file exists.");
                break;
            case BASS_ERROR_CODEC:
                printf("No codec exists for the samples.");
                break;
            case BASS_ERROR_NOTAVAIL:
                printf("The sound font does not contain necessary samples.");
                break;
            default:
                printf(TS_MSG_UnkownErrorPRT, error);
                break;
        }
        printf("\n");
    }

    return 0;
}

int TS_InitBass(){

    DWORD version = BASS_GetVersion();

    if(HIWORD(version)!=BASSVERSION){
        printf("[" PLUGINNAME "] Warning: Wrong version of BASS loaded (expected %x, version was %x). Crashes will likely follow.\n", BASSVERSION, version);
    }

	if (!BASS_Init(-1,44100,BASS_DEVICE_FREQ,NULL,NULL)) {
	    int error = BASS_ErrorGetCode();
        TS_ExplainBassErrorCode(error, true, false);

        BOOL couldstart = 1;

        if((error==BASS_ERROR_ALREADY)||(error==BASS_ERROR_ALREADY)){
            BASS_Free();
            couldstart = BASS_Init(-1, 44100, BASS_DEVICE_FREQ, NULL, NULL);
            error = BASS_ErrorGetCode();
            if(error==BASS_ERROR_FORMAT){
                BASS_Free();
            }
        }

        if(error==BASS_ERROR_FORMAT){
            BASS_Init(-1, 22050, FAILSAFE_BASS_INIT_FLAGS|BASS_DEVICE_FREQ, NULL, NULL);
        }

        if(!couldstart){
            error = BASS_ErrorGetCode();

            TS_ExplainBassErrorCode(error, false, (error==BASS_ERROR_FORMAT)?true:false);
        return 1;
        }


	}
	else{
        printf("[" PLUGINNAME "] Info: loaded and initialized BASS.\n");
	}
    TS_InitBassMidi();
    BASS_Start();
    return 0;
}

TS_AudioSample::~TS_AudioSample(){
    if(file!=NULL)
        free(file);

    BASS_SampleFree(sample);

}

TS_AudioStream::~TS_AudioStream(){
    if(file!=NULL)
        free(file);

    BASS_StreamFree(stream);
}

TS_AudioSample::TS_AudioSample(void){
    file    = NULL;
    sample  = BASS_SampleCreate(0, 44800, 0, 1, 0);
    volume  = 1.0f;
    pan     = 0.0f;
}

TS_AudioStream::TS_AudioStream(void){
    file    = NULL;
    volume  = 1.0f;
    pan     = 0.0f;
}

TS_AudioSample::TS_AudioSample(const char* name, TS_AudioSimul sim){
    file = STRDUP(name);
    simul = sim;
    sample = BASS_SampleLoad(0, file, 0, 0, (simul==TS_SINGLE)?1:8, 0);
    volume  = 1.0f;
    pan     = 0.0f;
}

TS_AudioStream::TS_AudioStream(const char *name, TS_AudioSimul sim){
    file = STRDUP(name);
    simul = sim;
    stream = BASS_StreamCreateFile(0, file, 0, 0, 0);
    volume  = 1.0f;
    pan     = 0.0f;

}

void TS_AudioStream::ResetPlayback(void) const{
    BASS_ChannelSetPosition(stream, 0, BASS_POS_BYTE);
    BASS_ChannelPlay(stream, repeat);
}

void TS_AudioSample::ResetPlayback(void) const{
    for(size_t i = 0; i<channels.size(); i++){
        BASS_ChannelSetPosition(channels[i].handle, 0, BASS_POS_BYTE);
        BASS_ChannelPlay(channels[i].handle, channels[i].repeat);
    }
}

void TS_AudioSample::Play(bool repeat){
        if((simul==TS_SINGLE)&&(channels.size()>1))
            channels.resize(1);

        if((simul==TS_SINGLE)&&(channels.size()==1))
            channels[0].handle = BASS_SampleGetChannel(sample, 0);
        else{
            TS_ChannelWrap *wrap = (TS_ChannelWrap *)malloc(sizeof(TS_ChannelWrap));
            wrap->handle = BASS_SampleGetChannel(sample, 1);
            wrap->ID = generateUniqueId(0);
            wrap->ptr = this;
            wrap->repeat = repeat;
            channels.push_back(*wrap);

            BASS_ChannelPlay(wrap->handle, repeat);
            BASS_ChannelSetSync(wrap->handle, BASS_SYNC_END, 0, ChannelCallback, (void *)wrap);
        }
}

void TS_AudioStream::Play(bool repeat){
        if((simul==TS_SINGLE)&&(BASS_StreamGetFilePosition(stream, BASS_FILEPOS_CURRENT)>1)){
            BASS_ChannelSetPosition(stream, 0, BASS_POS_BYTE);
        }
        else{
            BASS_ChannelPlay(stream, repeat);
        }
}

void TS_AudioStream::Stop(void){
        BASS_ChannelStop(stream);
}

void TS_AudioSample::Stop(void){
        BASS_SAMPLE sampleinfo;
        BASS_SampleGetInfo(sample, &sampleinfo);
        HCHANNEL *channels = (HCHANNEL *)malloc(sampleinfo.chans*sizeof(HCHANNEL));
        uint32_t numChannels = BASS_SampleGetChannels(sample, channels);
        for(uint32_t i = 0; i<numChannels; i++){
            BASS_ChannelStop(channels[i]);
        }
        free(channels);
}

void ChannelCallback(HSYNC handle, DWORD channel, DWORD data, void *user){

}

long long TS_AudioSample::GetPosition() const{
    return 0;
}

void TS_AudioSample::SetPosition(long long pos){
    assert(pos>=0);

}

void TS_AudioSample::SetVolume(float vol){

    if(volume==vol){
        return;
    }

    if((((float)fabs(float(volume-vol)))<VOLUME_RESOLUTION)&&(vol!=0.0f)&&(vol!=1.0f)){
        return;
    }

    volume = vol;

    if(type==TS_STREAM){
        for(size_t i = 0; i<channels.size(); i++){
            if((channels[i]->sample->handle==handle)||(handle==channels[i]->channel)){
                BASS_ChannelSetAttribute(channels[i]->channel, BASS_ATTRIB_VOL, volume);
            }
        }
    }
    else if(type==TS_SAMPLE){
        BASS_SAMPLE sampleInfo;
        BASS_SampleGetInfo(handle, &sampleInfo);
        sampleInfo.volume = vol;
        BASS_SampleSetInfo(handle, &sampleInfo);
    }
}

void TS_AudioSample::SetVolume(unsigned char vol){

    float nvol = ((float)vol);
    nvol/=255.0f;
    this->SetVolume(nvol);
}

float TS_AudioSample::GetVolume(){
    if(type!=TS_SAMPLE)
        return volume; //TODO: Add volume support for streams.

    BASS_SAMPLE sampleInfo;
    BASS_SampleGetInfo(handle, &sampleInfo);
    volume = sampleInfo.volume;
    return volume;
}

void TS_AudioSample::SetPan(float p){

    if(pan==p){
        return;
    }

    if((fabs(pan-p)<PAN_RESOLUTION)&&(p!=0.0f)&&(p!=1.0f)&&(p!=-1.0f)){
        return;
    }

    pan = p;


    if(type==TS_STREAM){
        for(size_t i = 0; i<channels.size(); i++){
            if((channels[i]->sample->handle==handle)||(handle==channels[i]->channel)){
                BASS_ChannelSetAttribute(channels[i]->channel, BASS_ATTRIB_PAN, pan);
            }
        }
    }
    else if (type==TS_SAMPLE){
        BASS_SAMPLE sampleInfo;
        BASS_SampleGetInfo(handle, &sampleInfo);
        sampleInfo.pan = p;
        BASS_SampleSetInfo(handle, &sampleInfo);
    }
}

void TS_AudioSample::SetPan(unsigned char p){
    float np = ((float)p);
    np/=255.0f;
    this->SetPan(np);
}

float TS_AudioSample::GetPan(){
    if(type!=TS_SAMPLE)
        return pan;

    BASS_SAMPLE sampleInfo;
    BASS_SampleGetInfo(handle, &sampleInfo);
    pan = sampleInfo.pan;
    return pan;
}

/*
    Sound.isPlaying(): Check if the sound is currently playing.
    Sound.isSeekable(): Returns true if the sound is seekable. Not all sound types are seekable, Ogg is.
    Sound.getLength(): Gets the length of the sound.
    Sound.clone(): Returns a copy of the sound object.
    Sound.getPosition(): Returns the position of the sound, zero if the sound isn't seekable.
    Sound.setPosition(position): Sets the position of the sound. Does nothing if the sound isn't seekable.
*/

bool TS_AudioSample::IsPlaying(){
    for(size_t i = 0; i<channels.size(); i++){
            if((channels[i]->sample->handle==handle)||(handle==channels[i]->channel)){
            DWORD isActive = BASS_ChannelIsActive(channels[i]->channel);
            if((isActive==BASS_ACTIVE_PLAYING)||(BASS_ACTIVE_STALLED)){
                return true;
            }
        }
    }
    return false;
}

long long TS_AudioSample::GetLength(void){
    if(type==TS_STREAM){
        long long length = BASS_StreamGetFilePosition(handle, BASS_FILEPOS_END);
        if(length>(long long)0)
            return length/10;

        long long end = BASS_ChannelGetLength(handle, BASS_POS_BYTE);
        double dlength = BASS_ChannelBytes2Seconds(handle, end);
        length = (dlength*1000.0d);

        //printf("[" PLUGINNAME "] Warning: Requested length of %s may be quite inaccurate. Supposed length is: %i, %f", file, end, dlength);

        return length;
    }
    else if(type==TS_SAMPLE){
        BASS_SAMPLE info;

        BASS_SampleGetInfo(handle, &info);
        long long length = info.length/info.freq;

        return length;
    }
    else{
        return 0;
    }
}

void TS_SetGlobalVolume(float volume){
    BASS_SetVolume(volume);
}

void TS_ResetGlobalVolume(){
    BASS_SetVolume(1.0f);
}

#ifdef _WIN32
#undef fabs
#endif
